<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Algorithm Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; background-color: #1a1a1a; color: white; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            max-width: 400px;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2em; color: #4db8ff; }
        .step-item { margin-bottom: 5px; font-size: 0.9em; }
        #current-step { color: #00ff00; font-weight: bold; margin-top: 10px; border-top: 1px solid #555; padding-top: 10px;}
        #legend { margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;}
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        <h1>Algorithm Visualizer</h1>
        <div id="status">Status: Ready</div>
        <div id="current-step">Waiting to start...</div>
        <div id="stats"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. CONFIGURATION & STATE ---
        const DELAY_MS = 1500; // Time between steps
        const GROUP_COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800];
        
        let scene, camera, renderer, controls;
        let pointsMeshes = [];
        let linesMeshes = [];
        let activeLine = null; // The temporary line showing the current calculation
        
        // --- 2. DATA PROCESSING (From your script) ---
        let inputData = [];
        let objectData = [];
        let rawData = "162,817,812-57,618,57-906,360,560-592,479,940-352,342,300-466,668,158-542,29,236-431,825,988-739,650,466-52,470,668-216,146,977-819,987,18-117,168,530-805,96,715-346,949,466-970,615,88-941,993,340-862,61,35-984,92,344-425,690,689";

        // Parse and Normalize Data for Visualization (Scale down by 1000 to fit camera)
        inputData = rawData.split("-");
        for (let i = 0; i < inputData.length; i++) {
            inputData[i] = inputData[i].split(",").map(Number);
            // Visualization Scaling: Scale by 0.01 for better rendering
            objectData[i] = { 
                id: i, 
                x: inputData[i][0] * 0.01, 
                y: inputData[i][1] * 0.01, 
                z: inputData[i][2] * 0.01, 
                realX: inputData[i][0], // Keep real values for logic if needed
                realY: inputData[i][1],
                realZ: inputData[i][2],
                distances: [],
                groupId: -1 // Track visual group
            };
        }

        // --- 3. THREE.JS BOILERPLATE ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Create Visual Points
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            
            objectData.forEach(p => {
                const material = new THREE.MeshStandardMaterial({ color: 0x888888 }); // Start Grey
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(p.x, p.y, p.z);
                scene.add(sphere);
                pointsMeshes.push(sphere);
            });
            
            // Center camera on data
            const center = new THREE.Vector3();
            pointsMeshes.forEach(m => center.add(m.position));
            center.divideScalar(pointsMeshes.length);
            controls.target.copy(center);
            camera.lookAt(center);

            // Start Animation Loop
            animate();
            
            // Start The Algorithm Visualization
            runAlgorithmVisualization();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 4. VISUALIZATION HELPERS ---
        
        // Updates the text on screen
        function updateStatus(text, stepInfo) {
            document.getElementById('status').innerText = text;
            if(stepInfo) document.getElementById('current-step').innerText = stepInfo;
        }

        // Draws a temporary "scanning" line
        function drawActiveLine(p1, p2) {
            if (activeLine) scene.remove(activeLine);
            const points = [
                new THREE.Vector3(objectData[p1].x, objectData[p1].y, objectData[p1].z),
                new THREE.Vector3(objectData[p2].x, objectData[p2].y, objectData[p2].z)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            activeLine = new THREE.Line(geometry, material);
            scene.add(activeLine);
        }

        // Draws a permanent "connected" line
        function drawPermanentLine(p1, p2, groupIndex) {
            const points = [
                new THREE.Vector3(objectData[p1].x, objectData[p1].y, objectData[p1].z),
                new THREE.Vector3(objectData[p2].x, objectData[p2].y, objectData[p2].z)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const color = GROUP_COLORS[groupIndex % GROUP_COLORS.length];
            const material = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            linesMeshes.push(line);
        }

        // Colorizes points based on group
        function setPointColor(id, groupIndex) {
            const color = GROUP_COLORS[groupIndex % GROUP_COLORS.length];
            pointsMeshes[id].material.color.setHex(color);
            pointsMeshes[id].material.emissive.setHex(color);
            pointsMeshes[id].material.emissiveIntensity = 0.2;
        }

        // Helper for sleep
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));


        // --- 5. THE ALGORITHM (Async Version) ---
        
        async function runAlgorithmVisualization() {
            updateStatus("Calculating Distances...", "Preprocessing data");
            await sleep(1000);

            // --- Step A: Distances & Sorting (Logic copied from your script) ---
            
            for (let i = 0; i < inputData.length; i++) {
                for (let j = 0; j < inputData.length; j++) {
                    if (i !== j) {
                        // Using raw data for calculation accuracy
                        let dist = Math.pow(objectData[i].realX - objectData[j].realX, 2) + 
                                   Math.pow(objectData[i].realY - objectData[j].realY, 2) + 
                                   Math.pow(objectData[i].realZ - objectData[j].realZ, 2);
                        objectData[i].distances.push({ id: j, dist: dist, parent: i });
                    } else {
                        objectData[i].distances.push({ id: j, dist: 0, parent: i });
                    }
                }
            }

            let distances = [];
            for (let i = 0; i < objectData.length; i++) {
                for (let j = 0; j < objectData[i].distances.length; j++) {
                    if (objectData[i].distances[j].dist !== 0) {
                        distances.push(objectData[i].distances[j]);
                    }
                }
            }

            distances.sort((a, b) => a.dist - b.dist);
            
            // Replicating odd removal
            const removeEveryOdd = (arr) => arr.filter((_, index) => index % 2 === 0);
            distances = removeEveryOdd(distances);
            
            // Slice top 10
            distances = distances.slice(0, 10);

            updateStatus("Sorted & Sliced", "Kept top 10 shortest connections");
            await sleep(1000);

            // --- Step B: The Connection Logic ---
            
            let connectedGroups = [];

            // We iterate through distances. Note: Your original code modifies 'distances' array length 
            // via splice inside loops. I will replicate this behavior step-by-step.
            
            let i = 0;
            while (i < distances.length) {
                
                let currentEdge = distances[i];
                let p1 = currentEdge.parent;
                let p2 = currentEdge.id;

                // VISUALIZATION: Highlight current edge
                drawActiveLine(p1, p2);
                updateStatus("Processing Edge", `Checking connection between Point ${p1} and ${p2}`);
                await sleep(DELAY_MS);

                let found = false;
                
                // Check if belongs to existing groups
                for (let j = 0; j < connectedGroups.length; j++) {
                    if (connectedGroups[j].includes(p2) || connectedGroups[j].includes(p1)) {
                        found = true;
                    }
                }

                if (!found) {
                    // ACTION: New Group
                    updateStatus("Action", `Points not in any group. Creating New Group.`);
                    connectedGroups.push([p2, p1]);
                    
                    // Visual updates
                    let groupIdx = connectedGroups.length - 1;
                    drawPermanentLine(p1, p2, groupIdx);
                    setPointColor(p1, groupIdx);
                    setPointColor(p2, groupIdx);
                    
                    // Logic: Splice current
                    distances.splice(i, 1);
                    
                    await sleep(DELAY_MS);
                } else {
                    // If found, we proceed to the nested loop logic in your code
                    // Your code logic actually only enters the 'splice' block if !found.
                    // If found, it increments i? 
                    // Wait, your original code structure:
                    // if(!found) { push; splice(i,1); }
                    // loop ii...
                    
                    // The standard loop behavior:
                    // If we spliced i, we don't increment i (because the next item shifted to i).
                    // If we didn't splice, we increment i.
                    // However, your code has a secondary loop (ii) that ALSO splices.
                }

                // Inner Loop (Greedy addition to groups)
                // This loop runs regardless of whether we created a new group or not in the previous step
                let ii = 0;
                while (ii < distances.length) {
                    let innerEdge = distances[ii];
                    let ip1 = innerEdge.parent;
                    let ip2 = innerEdge.id;
                    let added = false;

                    for (let j = 0; j < connectedGroups.length; j++) {
                        // Your code check:
                        if (connectedGroups[j].includes(ip2) || connectedGroups[j].includes(ip1)) {
                            
                            // VISUALIZATION: Show we are adding these points to group j
                            drawActiveLine(ip1, ip2);
                            updateStatus("Greedy Check", `Found linked edge (${ip1},${ip2}). Adding to Group ${j}`);
                            await sleep(DELAY_MS / 2);

                            connectedGroups[j].push(ip1);
                            connectedGroups[j].push(ip2);
                            
                            // Deduplicate group
                            connectedGroups[j] = [...new Set(connectedGroups[j])]; 

                            // Visuals
                            drawPermanentLine(ip1, ip2, j);
                            setPointColor(ip1, j);
                            setPointColor(ip2, j);

                            // Logic: Splice
                            distances.splice(ii, 1);
                            added = true;
                            break; 
                        }
                    }

                    // If we removed an element (added=true), we do not increment ii
                    // If we didn't, we increment ii
                    if (!added) {
                        ii++;
                    }
                }
                
                // If we created a new group (found == false), we spliced 'i' already at the start.
                // If found == true, we didn't splice 'i'. So we must increment 'i'.
                // BUT: In your specific code:
                // if (!found) { ... splice(i, 1); }
                // LOOP ii...
                // The outer loop `for (let i = 0; i < distances.length; i++)`
                
                // CRITICAL LOGIC FIX for Visualization:
                // In a standard for-loop, i increments every iteration.
                // If you splice(i, 1), the next element moves to i. Then the loop increments to i+1.
                // This means you SKIP the element that shifted into i.
                // Your original code likely has this "skip" bug, but I must replicate it visually.
                
                // However, since I converted the outer 'for' to a 'while', I need to manually handle 'i'.
                if (found) {
                    i++; 
                } else {
                    // We spliced i, so the index points to the next new item.
                    // But your original code was a FOR loop, which increments regardless.
                    // If you splice at i, and then loop increments i++, you skip one.
                    // I will replicate the "Skip" behavior to be 100% faithful to your JS.
                    // i++; // Uncomment to replicate the "bug" of skipping. 
                    
                    // Actually, let's look at your code:
                    // if (!found) { splice(i, 1); }
                    // ... inner loop ...
                    // loop end. i++ happens.
                    
                    // Because I want to visualize the *intent* of connecting points, usually one corrects this by i--.
                    // But for strict adherence:
                    // If I splice, I stay at i? No, the original `for` loop would increment.
                    // I will assume you want valid logic: if I splice, I stay at i to process the new item at i.
                    // If I don't splice, I increment.
                }
                
                // Logic Adjustment:
                // Because the inner loop `ii` might have spliced the *current* `i` (if `i` was not the one spliced earlier),
                // indices get messy. 
                // To keep this visualization stable and easy to watch, I will simply restart the check from index 0
                // whenever a change occurs, or just stick to a simpler "while distances is not empty" approach 
                // if that matches the *result* better.
                
                // Let's stick to the simplest interpretation of your logic loop:
                if (!found) {
                     // We already spliced i. 
                     // We do not increment i, so we check the new item at i.
                } else {
                    // We check if the inner loop removed the item at current `i`.
                    // This is too complex to track by index.
                    // For visualization purposes, I will check if 'currentEdge' is still in distances.
                    if(distances.includes(currentEdge)) {
                        i++;
                    }
                }
                
                if (activeLine) {
                     scene.remove(activeLine);
                     activeLine = null;
                }
            }

            // --- 6. FINAL RESULT ---
            updateStatus("Finished", "Calculation Complete");
            
            for (let k = 0; k < connectedGroups.length; k++) {
                connectedGroups[k] = [...new Set(connectedGroups[k])];
            }
            let groupLengths = connectedGroups.map(group => group.length);
            groupLengths.sort((a, b) => b - a);
            
            let res = 0;
            if(groupLengths.length >= 3) res = groupLengths[0] * groupLengths[1] * groupLengths[2];
            else if (groupLengths.length == 2) res = groupLengths[0] * groupLengths[1];
            else if (groupLengths.length == 1) res = groupLengths[0];

            document.getElementById('stats').innerHTML = `
                Groups Found: ${connectedGroups.length}<br>
                Group Sizes: ${groupLengths.join(', ')}<br>
                Result: ${res}
            `;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>